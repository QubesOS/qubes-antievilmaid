#!/bin/sh -e
export LC_ALL=C
. anti-evil-maid-lib
LABEL_SUFFIX_CHARS=0-9a-zA-Z=.-
BOOT_DIR=/boot
GRUB_DIR=$BOOT_DIR/grub2
GRUB_CFG=$GRUB_DIR/grub.cfg


usage() {
    cat <<END

Usage:
  anti-evil-maid-install [-s <suffix>] [-F] [-m] <device>

  Installs Anti Evil Maid to your system's boot partition, or to a different
  storage device (e.g. an SD card or a USB stick).


Arguments:
  -s: <device> gets labeled "$LABEL_PREFIX<suffix>"

      <suffix> can be composed of 0-13 characters from the alphabet
        $LABEL_SUFFIX_CHARS
      It defaults to <device>'s current suffix, if any, or the empty string
      otherwise. Each of your AEM installations must have a unique suffix.

      This suffix has no particular meaning, except that you can let it end
      in .rm=1 or .rm=0 to hint that <device> is removable or fixed,
      respectively, no matter what the Linux kernel detects.

  -F: passed on to mkfs.ext4 (don't ask for confirmation, etc.)

  -m: set up a multi-factor auth AEM media (EXPERIMENTAL)
      Using time-based one time password and a LUKS key file, provides
      resistance to shoulder surfing and video surveillance based passphrase
      snooping.


Examples:
  Install on the system's boot partition (assuming that it is /dev/sda1), and
  label its current filesystem "$LABEL_PREFIX":

    anti-evil-maid-install /dev/sda1

  Install on an SD card's first partition, replacing its data with a new ext4
  filesystem labeled "$LABEL_PREFIX.sd", and make it bootable:

    anti-evil-maid-install -s .sd /dev/mmcblk0p1

  Install MFA-enabled AEM on USB stick's first partition, overwriting it with
  a new ext4 filesystem and marking it bootable:

    anti-evil-maid-install -m /dev/sdb1

END

    exit 1
}


# check invocation

alias mfa=false
unset LABEL_SUFFIX F
while getopts s:Fhm opt; do
    case "$opt" in
        s) LABEL_SUFFIX=$OPTARG ;;
        F) F=-F ;;
        m) alias mfa=true ;;
        *) usage ;;
    esac
done

case "$LABEL_SUFFIX" in *[!$LABEL_SUFFIX_CHARS]*|??????????????*) usage; esac
LABEL=$LABEL_PREFIX$LABEL_SUFFIX

shift $(($OPTIND - 1))
case $# in
    1) PART_DEV=$1 ;;
    *) usage ;;
esac

if [ "$(id -ur)" != 0 ]; then
    log "This command must be run as root!"
    exit 1
fi

if [ -z "$(getluksuuids)" ]; then
    log "Anti Evil Maid requires encrypted disk!"
    exit 1
fi

systemctl start tcsd

# examine device

BOOT_MAJMIN=$(mountpoint -d "$BOOT_DIR") || BOOT_MAJMIN=
PART_DEV_MAJMIN=$(lsblk -dnr -o MAJ:MIN "$PART_DEV")

if external "$PART_DEV" && [ "$BOOT_MAJMIN" != "$PART_DEV_MAJMIN" ]; then
    alias replace=true
else
    alias replace=false
fi

WHOLE_DEV=$(lsblk -dnp -o PKNAME "$PART_DEV")
if ! [ -b "$WHOLE_DEV" -a "$WHOLE_DEV" != "$PART_DEV" ]; then
    log "Couldn't find parent device: $WHOLE_DEV"
    exit 1
fi

PART_DEV_REAL=$(readlink -f "$PART_DEV")
PART_NUM=${PART_DEV_REAL##*[!0-9]}
if ! [ "$PART_NUM" -gt 0 ]; then
    log "Couldn't extract partition number: $PART_NUM"
    exit 1
fi


# take ownership of the TPM using a randomly generated pw

alias took_ownership=false
if [ "$(cat /sys/class/tpm/tpm0/owned)" -ne 1 ]; then
    log "Your TPM is not owned yet."
    log "Generating a random TPM owner password..."
    ownerpw=$(head -c 8 /dev/random | hex)
    log "Password: $ownerpw"
    log "You may store this password in a safe place."

    log "Taking ownership of the TPM..."
    log "Please copy & paste the owner password generated above"
    if replace; then
        # external device, no need for SRK pw
        tpm_takeownership -z
    else
        # internal device, SRK pw required
        log "and then choose a SRK password."
        tpm_takeownership
    fi

    alias took_ownership=true
elif tpm_resetdalock -z 2>/dev/null; then
    # no owner pw set, abort (required for freshness
    # tokens to be used securely)
    log "TPM has no owner password set, aborting!"
    log "Please consult AEM readme for details."
    exit 1
fi


# create a random TPM ID

if ! tpm_id >/dev/null; then
    log "Creating a TPM ID..."
    TPM_ID_INDEX=$(tpm_id -i)

    if took_ownership; then
        pwdo="--pwdo=$ownerpw"
    else
        pwdo="--pwdo"
    fi

    # create a 20-byte write-once NVRAM area
    tpm_nvdefine -i "$TPM_ID_INDEX" -s 20 -p "WRITEDEFINE|WRITEALL" "$pwdo"
    # generate a random ID and write it into NVRAM
    head -c 20 /dev/random | tpm_nvwrite_stdin -i "$TPM_ID_INDEX" -s 20
    # lock the area to prevent non-owners from changing ID
    tpm_nvwrite -i "$TPM_ID_INDEX" -s 0

    # move TPM data to new location & restart tcsd
    systemctl stop tcsd
    mkdir -p "/var/lib/tpms/$(tpm_id)"
    mv /var/lib/tpms/unknown/* "/var/lib/tpms/$(tpm_id)/"
    rm -rf /var/lib/tpms/unknown
    systemctl start tcsd
fi


# define a TPM NVRAM area for storing freshness token hashes

if ! checktpmnvram; then
    log "Creating TPM NVRAM area for freshness tokens..."
    if took_ownership; then
        createtpmnvram "$ownerpw"
    else
        for try in 1 2 3; do
            read -s -p 'TPM owner password: ' ownerpw
            if createtpmnvram "$ownerpw"; then
                break
            elif [ $try -eq 3 ]; then
                log "Too many failures, aborting!"
                exit 1
            fi
        done
    fi
fi


# MFA-specific checks

if mfa && ! external "$PART_DEV"; then
    log "MFA AEM cannot be installed on the same"
    log "storage device as Qubes OS."
    exit 1
elif mfa && ! removable "$PART_DEV" "$LABEL" ; then
    log "MFA AEM can only be used with removable media."
    log "Should the device be, in fact, removable"
    log "(autodetection failed), add '.rm=1' at the end"
    log "of disk label suffix using the '-s' option."
    exit 1
fi


# This check (instead of a more obvious 'mountpoint $BOOT_DIR') should work
# even in unusual setups without any internal boot partition at all:

if [ ! -e "$GRUB_CFG" ]; then
    log "Couldn't find boot files at $BOOT_DIR"
    exit 1
fi


# keep old label unless overridden explicitly

OLD_LABEL=$(lsblk -dnr -o LABEL "$PART_DEV") ||
OLD_LABEL=

case "$OLD_LABEL" in "$LABEL_PREFIX"*)
    if [ -z "${LABEL_SUFFIX+set}" ]; then
        LABEL=$OLD_LABEL
    fi
esac


# create and/or label fs

if replace; then
    log "Creating new ext4 filesystem labeled $LABEL"
    mkfs.ext4 $F -L "$LABEL" "$PART_DEV"
else
    log "Labeling filesystem $LABEL"
    e2label "$PART_DEV" "$LABEL"
fi


# move secrets if label changed

if [   -n "$OLD_LABEL" -a \
       -e "$AEM_DIR/$OLD_LABEL" -a \
     ! -e "$AEM_DIR/$LABEL" ]; then
    mv -v "$AEM_DIR/$OLD_LABEL" "$AEM_DIR/$LABEL"
fi


# MFA: generate a TOTP seed

if mfa && [ ! -e "$AEM_DIR/$LABEL/secret.otp" ]; then
    log "Generating new 160-bit TOTP seed"
    mkdir -p "$AEM_DIR/$LABEL"
    head -c 20 /dev/random \
        | base32 -w 0 \
        | tr -d '=' \
        > "$AEM_DIR/$LABEL/secret.otp"

    # construct OTP URI
    otp_secret="$(cat "$AEM_DIR/$LABEL/secret.otp")"
    otp_uri="otpauth://totp/${LABEL}?secret=${otp_secret}"

    # create an ANSI text QR code and show it in the terminal
    echo "$otp_uri" | qrencode -t ansiutf8

    # show QR code
    log "Please scan the above QR code with your OTP device."

    # display the text form of secret to user, too
    human_readable_secret="$(echo "$otp_secret" | sed 's/\(....\)/\1\ /g')"
    log "Alternatively, you may manually enter the following"
    log "secret into your OTP device:"
    log "    $human_readable_secret"

    if timedatectl status | grep -q 'RTC in local TZ: yes'; then
        log ""
        log "WARNING: Your computer's RTC (real-time clock) is set"
        log "to store time in local timezone. This will cause wrong"
        log "TOTP codes to be generated during AEM boot. Please fix"
        log "this by running (as root):"
        log "    timedatectl set-local-rtc 0"
    fi

    # check whether secret was provisioned correctly
    log ""
    log "After you have set up your OTP device, please enter"
    log "the code displayed on your device and press <ENTER>"
    log "to continue."
    log ""

    totp_tries=3
    for try in $(seq $totp_tries); do
        read -p "Code: "
        if ! oathtool --totp -b "$otp_secret" "$REPLY" >/dev/null; then
            log "Entered TOTP code is invalid!"
            if [ "$try" -lt $totp_tries ]; then
                log "Please check clock synchronization."
                log "If you made mistake while manually entering the secret,"
                log "remove the added token, repeat the process & try again."
                log ""
            else
                log "Aborting AEM setup..."
                exit 1
            fi
        else
            break
        fi
    done

    log "TOTP code matches, continuing AEM setup."
fi


# MFA: generate and enroll a LUKS key file if not already present

if mfa && [ ! -e "$AEM_DIR/$LABEL/secret.key" ]; then
    log "Generating new LUKS key file"
    rawkey=$(mktemp)
    head -c 64 /dev/random > "$rawkey"

    log "Encrypting key file"
    mkdir -p "$AEM_DIR/$LABEL"
    scrypt enc "$rawkey" "$AEM_DIR/$LABEL/secret.key"

    for dev in $(getluksuuids); do
        devname=$(readlink -f "/dev/disk/by-uuid/$dev")

        # check if LUKS device has any free key slots
        if ! cryptsetup luksDump "/dev/disk/by-uuid/$dev" \
                | grep -q DISABLED; then
            log "FATAL: Device $devname (UUID $dev)"
            log "has no free key slots!"
            exit 1
        fi

        log "Adding key file to new key slot for $devname (UUID $dev)"
        for try in 1 2 3; do
            if cryptsetup luksAddKey "/dev/disk/by-uuid/$dev" "$rawkey"; then
                break
            elif [ $try -eq 3 ]; then
                log "ERROR: Wrong password, aborting!"
                log "You need to manually finish enrolling $rawkey"
                log "as a key file for all desired LUKS devices, then"
                log "remove the $rawkey file and re-run this script."
                exit 1
            fi
        done
    done

    log "Shredding the unencrypted key file"
    shred -zu "$rawkey"
fi


# add the AEM media being created to the freshness database

if suffixtoslot "$LABEL_SUFFIX" >/dev/null; then
    log "WARNING: (possibly another) AEM media with the same"
    log "label suffix is already enrolled in the freshness token"
    log "database! Overwriting will result in the old AEM media"
    log "failing to perform a successful AEM boot. If you're"
    log "simply reinstalling on the same device or intentionally"
    log "replacing an old AEM media that was lost/destroyed/etc.,"
    log "it is safe to continue."
    read -p "Proceed? [y/N] " response
    case "$response" in
        y|Y) echo "continuing..." ;;
        *) exit ;;
    esac
else
    assignslottosuffix "$LABEL_SUFFIX"
    slot=$(suffixtoslot "$LABEL_SUFFIX")
    log "Assigned slot $slot to this AEM media"
fi


# mount

if CUR_MNT=$(devtomnt "$PART_DEV") && [ -n "$CUR_MNT" ]; then
    PART_MNT=$CUR_MNT
else
    CUR_MNT=
    PART_MNT=/mnt/anti-evil-maid/$LABEL

    log "Mounting at $PART_MNT"
    mkdir -p "$PART_MNT"
    mount "$PART_DEV" "$PART_MNT"
fi


# sync

mkdir -p "$PART_MNT/aem"
synctpms "$LABEL" "$PART_MNT"
mkdir -p "$AEM_DIR/$LABEL"


# make device bootable

if replace; then
    log "Setting bootable flag"
    parted -s "$WHOLE_DEV" set "$PART_NUM" boot on

    log "Copying boot files"
    find "$BOOT_DIR" -maxdepth 1 -type f ! -name 'initramfs-*.img' \
         -exec cp {} "$PART_MNT" \;

    # TODO: If dracut is configured for no-hostonly mode (so we don't have to
    # worry about picking up loaded kernel modules), just copy each initramfs
    # instead of regenerating it
    for img in "$BOOT_DIR"/initramfs-*.img; do
        ver=${img%.img}
        ver=${ver##*initramfs-}
        log "Generating initramfs for kernel $ver"
        dracut --force "$PART_MNT/${img##*/}" "$ver"
    done

    log "Copying GRUB themes"
    dst=$PART_MNT/${GRUB_DIR#$BOOT_DIR/}
    mkdir "$dst"
    cp -r "$GRUB_DIR/themes" "$dst"

    log "Installing GRUB"
    grub2-install --boot-directory="$PART_MNT" "$WHOLE_DEV"

    log "Bind mounting $PART_MNT at $BOOT_DIR"
    mount --bind "$PART_MNT" "$BOOT_DIR"

    log "Generating GRUB configuration"
    grub2-mkconfig -o "$GRUB_CFG"

    log "Unmounting bind mounted $BOOT_DIR"
    umount "$BOOT_DIR"
fi


if [ -z "$CUR_MNT" ]; then
    log "Unmounting $PART_MNT"
    umount "$PART_MNT"
fi
